<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>MCQ Practice</title>
<style>
  :root{
    --bg:#ffffff; --card:#ffffff; --border:#d9d9d9; --text:#1f2937; --muted:#6b7280; --primary:#2563eb; --btn:#f3f4f6;
  }
  *{box-sizing:border-box}
  body{margin:0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--text);}
  header{position:sticky;top:0;z-index:10;display:flex;align-items:center;justify-content:space-between;padding:10px 16px;border-bottom:1px solid var(--border);background:#fff;}
  header .status{display:flex;align-items:center;gap:10px;font-size:14px;color:var(--muted);}
  header .url{max-width:65%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;color:#6b7280}
  main{max-width:760px;margin:24px auto 96px;padding:0 16px;}
  .card{border:1px solid var(--border);border-radius:12px;padding:18px;background:var(--card);}
  .qtitle{font-weight:600;margin:0 0 10px 0}
  .option{display:block;margin:8px 0;font-size:15px;line-height:1.35;}
  .controls{margin-top:12px;display:flex;gap:10px;flex-wrap:wrap}
  button{border:1px solid var(--border);background:var(--btn);padding:8px 14px;border-radius:8px;font-size:14px;cursor:pointer;}
  button.primary{background:#2563eb;color:#fff;border-color:#1d4ed8}
  button:disabled{opacity:.5;cursor:not-allowed}
  .progress{margin-top:10px;color:var(--muted);font-size:14px}
  .feedback{margin-top:8px;font-weight:600}
  .correct{color:#16a34a}
  .wrong{color:#dc2626}
  .footer{position:fixed;bottom:0;left:0;right:0;display:flex;justify-content:center;padding:14px;background:linear-gradient(to top, rgba(255,255,255,0.95), rgba(255,255,255,0.8));border-top:1px solid var(--border);gap:10px;}
  .footer button{min-width:120px}
  .nav{display:flex;align-items:center;gap:8px;margin-top:14px;color:var(--muted);font-size:14px}
  .divider{flex:1}
  .hint{font-size:13px;color:var(--muted);margin-top:4px}
  .checkbox{transform:scale(1.1);margin-right:8px}
  .filters{display:flex;gap:8px;flex-wrap:wrap;margin:0 0 12px 0}
  .filters input{padding:8px;border:1px solid var(--border);border-radius:8px;width:100%;max-width:320px}
</style>
</head>
<body>
<header>
  <div class="status">
    <span id="clock">--:--</span>
    <span aria-hidden="true">üîï</span>
  </div>
  <div class="url">quiz.practice</div>
  <div style="width:24px"></div>
</header>

<main>
  <div class="filters">
    <input id="search" placeholder="Search in question text..." />
    <button id="applySearch">Search</button>
    <button id="clearSearch">Clear</button>
  </div>
  <div class="card">
    <p class="qtitle" id="qtitle"></p>
    <div id="options"></div>
    <div class="controls">
      <button id="checkBtn" class="primary">Check</button>
      <button id="saveBtn">Save For Later</button>
      <button id="continueBtn" disabled>Continue</button>
      <button id="showAnsBtn">Reveal Answer</button>
      <button id="reportBtn">Report Error</button>
      <button id="editBtn">Edit</button>
      <button id="addQBtn">Add Question</button>
      <button id="exportBtn">Export Corrections</button>
    </div>
    <div class="feedback" id="feedback"></div>
    <div class="progress" id="progress"></div>
  </div>
<div id="editor" style="display:none; margin-top:10px; padding:10px; border:1px solid #ddd; border-radius:8px;">
  <label>Stem:<br><textarea id="editStem" style="width:100%; height:60px;"></textarea></label><br><br>
  <label>Options:<br><textarea id="editOptions" style="width:100%; height:100px;"></textarea></label><br><br>
  <label>Correct answers (letters, comma-separated):<br>
    <input id="editCorrect" style="width:100%;" />
  </label><br><br>
  <button id="saveEditBtn">Save Changes</button>
  <button id="cancelEditBtn">Cancel</button>
</div>
  <div id="newQ" style="display:none; margin-top:10px; padding:10px; border:1px solid #ddd; border-radius:8px;">
  <h4>Add New Question</h4>
  <label>Question ID (e.g., XII.110):<br>
    <input id="newQId" style="width:100%;" />
  </label><br><br>

  <label>Stem:<br>
    <textarea id="newQStem" style="width:100%; height:60px;"></textarea>
  </label><br><br>

  <label>Type:<br>
    <select id="newQType" style="width:100%;">
      <option value="single">single (one correct)</option>
      <option value="multi">multi (multiple correct)</option>
    </select>
  </label><br><br>

  <label>Options (one per line, like ‚Äúa. text‚Äù, ‚Äúb. text‚Äù‚Ä¶):<br>
    <textarea id="newQOptions" style="width:100%; height:120px;"></textarea>
  </label><br><br>

  <label>Correct answers (letters, comma-separated; e.g., ‚Äúc‚Äù or ‚Äúa,c,e‚Äù):<br>
    <input id="newQCorrect" style="width:100%;" />
  </label><br><br>

  <button id="saveNewQBtn">Save Question</button>
  <button id="cancelNewQBtn">Cancel</button>
</div>
  <div class="nav">
    <button id="prevBtn">‚óÄÔ∏é Prev</button>
    <div class="divider"></div>
    <button id="nextBtn">Next ‚ñ∂Ô∏é</button>
  </div>
  <p class="hint">Tip: ‚ÄúSave For Later‚Äù stores your current selection locally on this device.</p>
</main>

<div class="footer" role="toolbar" aria-label="Bottom actions">
  <button id="jumpStartBtn">Jump to start</button>
  <button id="jumpEndBtn">Jump to end</button>
</div>

<script>
let ALL = [];
let QUESTIONS = [];
let idx = 0;
const selections = loadSelections();

fetch('questions_parsed_full_v2.json')
  .then(r => r.json())
  .then(data => { ALL = data; QUESTIONS = ALL; mergeAdded(); render(); })
  .catch(err => { document.getElementById('qtitle').textContent = 'Failed to load questions.'; });

function render(){
  const q = QUESTIONS[idx];
  if(!q){ document.getElementById('qtitle').textContent = 'No questions match.'; return;}
  document.getElementById('qtitle').textContent = `${q.id}  ${q.stem}`;
  const optWrap = document.getElementById('options');
  optWrap.innerHTML = '';
  q.options.forEach(opt => {
    const label = document.createElement('label');
    label.className = 'option';
    const input = document.createElement('input');
    input.type = (q.type === 'single') ? 'radio' : 'checkbox';
    input.name = 'opts';
    input.value = opt.key;
    input.className = 'checkbox';
    const saved = selections[q.id] || [];
    if(saved.includes(opt.key)) input.checked = true;
    label.appendChild(input);
    label.appendChild(document.createTextNode(' ' + opt.text));
    optWrap.appendChild(label);
  });
  document.getElementById('progress').textContent = `${idx+1} of ${QUESTIONS.length}`;
  setFeedback('');
  document.getElementById('continueBtn').disabled = true;
}

function setFeedback(text, cls=''){
  const fb = document.getElementById('feedback');
  fb.textContent = text;
  fb.className = 'feedback ' + cls;
}

document.getElementById('checkBtn').addEventListener('click', () => {
  const q = QUESTIONS[idx];
  const selected = Array.from(document.querySelectorAll('input[name="opts"]:checked')).map(i=>i.value).sort();
  const correct = [...q.correct].sort();
  if(JSON.stringify(selected) === JSON.stringify(correct)){
    setFeedback('‚úÖ Correct!', 'correct');
    document.getElementById('continueBtn').disabled = false;
  }else{
    setFeedback('‚ùå Try again', 'wrong');
  }
});

document.getElementById('showAnsBtn').addEventListener('click', () => {
  const q = QUESTIONS[idx];
  setFeedback('Answer: ' + q.correct.join(', '), 'correct');
});

document.getElementById('saveBtn').addEventListener('click', () => {
  const q = QUESTIONS[idx];
  const selected = Array.from(document.querySelectorAll('input[name="opts"]:checked')).map(i=>i.value);
  selections[q.id] = selected;
  localStorage.setItem('mcqSelections', JSON.stringify(selections));
  setFeedback('üíæ Saved for later on this device.');
  setTimeout(()=> setFeedback(''), 1200);
});

document.getElementById('continueBtn').addEventListener('click', goNext);
document.getElementById('prevBtn').addEventListener('click', () => { if(idx>0){ idx--; render(); }});
document.getElementById('nextBtn').addEventListener('click', goNext);
document.getElementById('jumpStartBtn').addEventListener('click', () => { idx = 0; render(); });
document.getElementById('jumpEndBtn').addEventListener('click', () => { idx = QUESTIONS.length-1; render(); });

document.getElementById('applySearch').addEventListener('click', () => {
  const q = document.getElementById('search').value.trim().toLowerCase();
  if(!q){ QUESTIONS = ALL; idx = 0; render(); return; }
  QUESTIONS = ALL.filter(item => (item.stem + ' ' + item.options.map(o=>o.text).join(' ')).toLowerCase().includes(q));
  idx = 0; render();
});
document.getElementById('clearSearch').addEventListener('click', () => {
  document.getElementById('search').value = '';
  QUESTIONS = ALL; idx = 0; render();
});

function goNext(){
  if(idx < QUESTIONS.length-1){ idx++; render(); }
  else { setFeedback("üéâ You've reached the end.", 'correct'); }
}

function loadSelections(){
  try{ return JSON.parse(localStorage.getItem('mcqSelections') || '{}'); }catch(e){ return {}; }
}
(function initClock(){
  const clock = document.getElementById('clock');
  const upd = ()=>{
    const d = new Date();
    const pad = n => n.toString().padStart(2,'0');
    clock.textContent = `${pad(d.getHours())}:${pad(d.getMinutes())}`;
  };
  upd(); setInterval(upd, 10000);
})();
// --- Error reporting and editing feature ---
let reports = JSON.parse(localStorage.getItem('reports') || '[]');
let edits = JSON.parse(localStorage.getItem('edits') || '{}');

document.getElementById('reportBtn').addEventListener('click', () => {
  const q = QUESTIONS[idx];
  const reason = prompt("Describe the error (stem/options/answer mismatch):");
  if(reason){
    reports.push({id:q.id, stem:q.stem, reason});
    localStorage.setItem('reports', JSON.stringify(reports));
    alert("Error reported and saved locally.");
  }
});
document.getElementById('editBtn').addEventListener('click', () => {
  const q = QUESTIONS[idx];
  document.getElementById('editor').style.display = 'block';
  document.getElementById('editStem').value = q.stem;
  document.getElementById('editOptions').value = q.options.map(o => `${o.key}. ${o.text}`).join("\n");
  document.getElementById('editCorrect').value = q.correct.join(",");
});

document.getElementById('cancelEditBtn').addEventListener('click', () => {
  document.getElementById('editor').style.display = 'none';
});

document.getElementById('saveEditBtn').addEventListener('click', () => {
  const q = QUESTIONS[idx];
  q.stem = document.getElementById('editStem').value.trim();
  const optsLines = document.getElementById('editOptions').value.split("\n").map(l=>l.trim()).filter(Boolean);
  q.options = optsLines.map(line=>{
    const m = line.match(/^([a-e])\.\s*(.*)$/i);
    return {key:m[1].toLowerCase(), text:m[2]};
  });
  q.correct = document.getElementById('editCorrect').value.split(",").map(x=>x.trim().toLowerCase()).filter(Boolean);
  edits[q.id] = q;
  localStorage.setItem('edits', JSON.stringify(edits));
  alert("Edits saved locally. They will override this question next time.");
  document.getElementById('editor').style.display = 'none';
  render(); // re-render with edits
});

// Apply edits when rendering
const oldRender = render;
render = function(){
  const q = QUESTIONS[idx];
  if(edits[q.id]){
    Object.assign(q, edits[q.id]);
  }
  oldRender();
};
  // ----- Add-new-question feature -----
let added = JSON.parse(localStorage.getItem('added_questions') || '[]');

// merge added questions after the JSON loads
// (put this right after you set ALL = data; QUESTIONS = ALL;)
function mergeAdded() {
  if (!Array.isArray(added)) added = [];
  // avoid duplicates by id
  const existingIds = new Set(ALL.map(q => q.id));
  const filtered = added.filter(q => !existingIds.has(q.id));
  QUESTIONS = ALL.concat(filtered);
}
 // hook into your fetch then(...) where you currently have: 
 // .then(data => { ALL = data; QUESTIONS = ALL; render(); })
 // change to:
 // .then(data => { ALL = data; QUESTIONS = ALL; mergeAdded(); render(); })

// open the new-question panel
document.getElementById('addQBtn').addEventListener('click', () => {
  document.getElementById('newQ').style.display = 'block';
  // sensible defaults
  document.getElementById('newQId').value = '';
  document.getElementById('newQStem').value = '';
  document.getElementById('newQType').value = 'single';
  document.getElementById('newQOptions').value = 'a. \nb. \nc. \nd. \ne. ';
  document.getElementById('newQCorrect').value = '';
});

// cancel
document.getElementById('cancelNewQBtn').addEventListener('click', () => {
  document.getElementById('newQ').style.display = 'none';
});

// save
document.getElementById('saveNewQBtn').addEventListener('click', () => {
  const id = document.getElementById('newQId').value.trim();
  const stem = document.getElementById('newQStem').value.trim();
  const type = document.getElementById('newQType').value;
  const optsLines = document.getElementById('newQOptions').value.split('\n').map(s=>s.trim()).filter(Boolean);
  const correct = document.getElementById('newQCorrect').value.split(',').map(s=>s.trim().toLowerCase()).filter(Boolean);

  if(!id || !stem || optsLines.length < 2 || correct.length === 0){
    alert('Please fill ID, stem, at least 2 options, and at least 1 correct letter.');
    return;
  }

  // parse options like "a. text"
  const options = [];
  for(const line of optsLines){
    const m = line.match(/^([a-e])\.\s*(.+)$/i);
    if(!m){ alert('Options must look like "a. text"'); return; }
    options.push({ key: m[1].toLowerCase(), text: m[2] });
  }

  const q = { id, stem, type, options, correct };

  // prevent duplicate IDs with existing content
  const existsInAll = QUESTIONS.some(x => x.id === id);
  if(existsInAll){
    const ok = confirm('A question with this ID exists. Add anyway as a new item?');
    if(!ok) return;
  }

  added.push(q);
  localStorage.setItem('added_questions', JSON.stringify(added));

  // add to in-memory list so it appears immediately
  QUESTIONS.push(q);

  alert('New question saved (locally). It will appear in search and navigation.');
  document.getElementById('newQ').style.display = 'none';
  // jump to the new question
  idx = QUESTIONS.length - 1;
  render();
});
  document.getElementById('exportBtn').addEventListener('click', () => {
  const data = {
    reports: reports,
    edits: edits,
    added: added || []
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'corrections.json';
  a.click();
  URL.revokeObjectURL(url);
});
</script>
</body>
</html>
